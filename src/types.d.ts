// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_VITE_DEV_SERVER_URL: string;
declare const MAIN_WINDOW_VITE_NAME: string;

// Preload types
interface ThemeModeContext {
  toggle: () => Promise<boolean>;
  dark: () => Promise<void>;
  light: () => Promise<void>;
  system: () => Promise<boolean>;
  current: () => Promise<"dark" | "light" | "system">;
}
interface ElectronWindow {
  minimize: () => Promise<void>;
  maximize: () => Promise<void>;
  close: () => Promise<void>;
}

interface ProjectApi {
  openFolder: (folderPath?: string) => Promise<void>;
  getCurrentProject: () => Promise<string | null>;
  setCurrentProject: (projectPath: string) => Promise<void>;
  openFile: (filePath: string) => Promise<{ content: string; path: string }>;
  saveFile: (filePath: string, content: string) => Promise<void>;
  createFile: (filePath: string, content?: string) => Promise<void>;
  createFolder: (folderPath: string) => Promise<void>;
  deleteFile: (filePath: string) => Promise<void>;
  deleteFolder: (folderPath: string) => Promise<void>;
  renameFile: (oldPath: string, newPath: string) => Promise<void>;
  renameFolder: (oldPath: string, newPath: string) => Promise<void>;
  getFileStats: (filePath: string) => Promise<{
    size: number;
    createdAt: Date;
    modifiedAt: Date;
  }>;
  getDirectoryTree: (
    rootPath: string,
    options?: { depth?: number; includeFiles?: boolean },
  ) => Promise<any>;
  watchFileChanges: (filePath: string) => Promise<void>;
  unwatchFileChanges: (filePath: string) => Promise<void>;
  searchFiles: (
    query: string,
    rootPath?: string,
    options?: { includePatterns?: string[]; excludePatterns?: string[] },
  ) => Promise<string[]>;
  searchInFiles: (
    query: string,
    rootPath?: string,
    options?: { filePatterns?: string[]; excludePatterns?: string[] },
  ) => Promise<string[]>;
  getRecentProjects: () => Promise<string[]>;
  addRecentProject: (
    projectPath: string,
    projectName?: string,
  ) => Promise<void>;
  removeRecentProject: (projectPath: string) => Promise<void>;
  setLastOpenedProject: (projectPath: string) => Promise<void>;
  getLastOpenedProject: () => Promise<string | null>;
}

interface AI {
  sendMessage: (payload: {
    messages: import("ai").CoreMessage[];
    requestId: string;
    apiType?: string;
  }) => Promise<{ success: boolean; requestId: string }>;
  onStreamChunk: (
    callback: (data: { requestId: string; chunk: Uint8Array }) => void,
  ) => void;
  onStreamEnd: (callback: (data: { requestId: string }) => void) => void;
  onStreamError: (
    callback: (data: { requestId: string; error: string }) => void,
  ) => void;
  removeAllListeners: () => void;
}

interface Agents {
  sendMessage: (payload: {
    taskId: string;
    messages: import("ai").CoreMessage[];
    requestId: string;
  }) => Promise<{ success: boolean; requestId: string }>;
  onStreamChunk: (
    callback: (data: {
      taskId: string;
      requestId: string;
      chunk: Uint8Array;
    }) => void,
  ) => void;
  onStreamEnd: (
    callback: (data: { taskId: string; requestId: string }) => void,
  ) => void;
  onStreamError: (
    callback: (data: {
      taskId: string;
      requestId: string;
      error: string;
    }) => void,
  ) => void;
  startAgent: (taskId: string) => Promise<{ success: boolean; error?: string }>;
  stopAgent: (taskId: string) => Promise<{ success: boolean; error?: string }>;
  pauseAgent: (taskId: string) => Promise<{ success: boolean; error?: string }>;
  resumeAgent: (
    taskId: string,
  ) => Promise<{ success: boolean; error?: string }>;
  onStatusUpdate: (callback: (data: any) => void) => void;
  createWorktree: (
    taskId: string,
    branchName: string,
  ) => Promise<{ success: boolean; error?: string; worktreePath?: string }>;
  deleteWorktree: (
    taskId: string,
  ) => Promise<{ success: boolean; error?: string }>;
  switchWorktree: (
    taskId: string,
  ) => Promise<{ success: boolean; error?: string }>;
  onWorktreeStatusChange: (callback: (data: any) => void) => void;
  removeAllListeners: () => void;
}

interface SettingsApi {
  // Regular settings
  get: <T = any>(key: string) => Promise<T | undefined>;
  set: (key: string, value: any) => Promise<boolean>;
  getAll: () => Promise<any>;
  reset: () => Promise<boolean>;
  export: () => Promise<string>;
  import: (settingsJson: string) => Promise<boolean>;

  // Secure settings (API keys, tokens, etc.)
  getSecure: (key: string) => Promise<string | undefined>;
  setSecure: (key: string, value: string) => Promise<boolean>;
  deleteSecure: (key: string) => Promise<boolean>;
  listSecureKeys: () => Promise<string[]>;
}

interface TerminalApi {
  create: (options?: {
    cwd?: string;
    title?: string;
  }) => Promise<{ id: string; title: string; cwd: string; pid: number }>;
  write: (terminalId: string, data: string) => Promise<boolean>;
  resize: (terminalId: string, cols: number, rows: number) => Promise<boolean>;
  kill: (terminalId: string) => Promise<boolean>;
  killAll: () => Promise<boolean>;
  list: () => Promise<
    { id: string; title: string; cwd: string; pid: number }[]
  >;
  onData: (
    callback: (data: { terminalId: string; data: string }) => void,
  ) => () => void;
  onExit: (
    callback: (data: { terminalId: string; exitCode: number }) => void,
  ) => () => void;
  onError: (
    callback: (data: { terminalId: string; error: string }) => void,
  ) => () => void;
  removeAllListeners: () => void;
}

interface ShellApi {
  showItemInFolder: (filePath: string) => Promise<void>;
  openExternal: (url: string) => Promise<void>;
}

declare interface Window {
  themeMode: ThemeModeContext;
  electronWindow: ElectronWindow;
  projectApi: ProjectApi;
  ai: AI;
  agents: Agents;
  settingsApi: SettingsApi;
  terminalApi: TerminalApi;
  shellApi: ShellApi;
}
